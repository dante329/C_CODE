#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

/*
1.按位与（ & ）
注意（只提一遍，其它运算符同理）：a & b是对 a 和 b 两个数进行操作，先将两个数的数值转化为二进制形式，再一一对应进行操作

按位与操作会将两个操作数的每一对应位进行逻辑与操作

只有当两个对应的二进制位都为1时，结果为1；否则为0

注意：二进制的 1 被代表真，而 二进制的 0 代表假，用 对二进制的每一位进行逻辑与（ && ）操作来理解两个数的按位与（ & ）运算更为易懂，逻辑与就是两个条件必须同时为真（两个位同时为1）才是真（对应的结果位为1），大家不需要去记按位与遇到0就变0这种口诀。



int a = 5; // 二进制: 0101

int b = 3; // 二进制: 0011

int c = a & b; // 结果: 0001 (即 1)

2. 按位或（ | ）
按位或操作将两个操作数的每一对应位进行逻辑或操作

只要有一个位为1，结果为1；如果两位都为0，结果为0

int a = 5; // 二进制: 0101

int b = 3; // 二进制: 0011

int c = a | b; // 结果: 0111 (即 7)

3. 按位异或（ ^ ）
当两个位不同（一个为1，一个为0）时，结果为1；当两个位相同时，结果为0

int a = 5; // 二进制: 0101

int b = 3; // 二进制: 0011

int c = a ^ b; // 结果: 0110 (即 6) 

4. 按位取反（~）
按位取反是单目运算符，它将操作数的每一位取反，将二进制数中的0变为1，1变为0。

int a = 5; // 二进制: 0000 0101

int c = ~a; // 结果: 1111 1010 （1111 1010是以补码的形式存储在c中的，而负数的值要将补码转化成原码才能得到，如下过程：

1111 1010 - 补码 

1111 1001 - 反码

1000 0110 - 原码）

printf("%d", c); // ( 打印结果为 -6) 

5. 左移（ << ）
左移操作将操作数的二进制位向左移动指定的位数，右侧补0

意义：每左移一位，相当于将原数乘以2

int a = 5; // 二进制: 0000 0101

int c = a << 1; // 结果: 0000 1010 (即 10)

6. 右移（ >> ）
右移操作将操作数的二进制位向右移动指定的位数

右移操作有两种补位方式：

6.1 算术右移
保留符号位，用符号位的值（0或1）来填补高位，正数就补0，负数就补1。这种方式通常用于带符号数的右移，因为它可以保留正负号的意义

int a = -8; // 二进制（假设32位）: 11111111 11111111 11111111 11111000

int b = a >> 1; // 右移1位，得到: 11111111 11111111 11111111 11111100 (-4)

6.2 逻辑右移 
直接在高位补0，不考虑符号位。逻辑右移一般用于无符号数（unsigned integers）或单纯的二进制位操作

unsigned int a = 8; // 二进制: 00000000 00000000 00000000 00001000

unsigned int b = a >> 1; // 右移1位，得到: 00000000 00000000 00000000 00000100 (4)

补充：位运算符的常见应用

x |= (1 << n)  将x的第n位设置为1

x &= ~(1 << n)   将x的第n位设置为0

x ^= (1 << n)  将x的第n位翻转

n & (n - 1) == 0  判断 n 是否是 2 的幂

n | (n + 1)           将最低位的 1 改为 1

n & (-n)                 提取 n 中最低的 1 所在的位

n ^ (n - 1)                计算连续的 1 的数量
*/